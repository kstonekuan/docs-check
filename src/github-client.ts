import { promises as fs } from "node:fs";
import { join } from "node:path";
import { Octokit } from "@octokit/rest";
import { GitOperations } from "./git-operations.js";
import type {
  AnalysisResult,
  DocumentationIssue,
  GitHubActionResult,
  GitHubRepository,
} from "./types.js";

export class GitHubClient {
  private octokit: Octokit;

  constructor(token: string) {
    this.octokit = new Octokit({
      auth: token,
    });
  }

  async createIssuesFromAnalysis(
    repository: GitHubRepository,
    analysisResult: AnalysisResult
  ): Promise<GitHubActionResult[]> {
    const results: GitHubActionResult[] = [];

    try {
      // Group issues by severity for better organization
      const highSeverityIssues = analysisResult.issues.filter((issue) => issue.severity === "high");
      const mediumSeverityIssues = analysisResult.issues.filter(
        (issue) => issue.severity === "medium"
      );
      const lowSeverityIssues = analysisResult.issues.filter((issue) => issue.severity === "low");

      // Create high severity issues individually
      for (const issue of highSeverityIssues) {
        const result = await this.createSingleIssue(repository, issue);
        results.push(result);
      }

      // Create grouped issues for medium and low severity
      if (mediumSeverityIssues.length > 0) {
        const result = await this.createGroupedIssue(
          repository,
          "Medium Priority Documentation Issues",
          mediumSeverityIssues,
          "medium"
        );
        results.push(result);
      }

      if (lowSeverityIssues.length > 0) {
        const result = await this.createGroupedIssue(
          repository,
          "Low Priority Documentation Issues",
          lowSeverityIssues,
          "low"
        );
        results.push(result);
      }
    } catch (error) {
      throw new Error(
        `Failed to create GitHub issues: ${error instanceof Error ? error.message : String(error)}`
      );
    }

    return results;
  }

  private async createSingleIssue(
    repository: GitHubRepository,
    issue: DocumentationIssue
  ): Promise<GitHubActionResult> {
    const labels = this.getLabelsForIssue(issue);

    let body = `**Type:** ${issue.type}\n**Severity:** ${issue.severity}\n\n`;
    body += `**Description:**\n${issue.description}\n\n`;

    if (issue.file) {
      body += `**File:** \`${issue.file}\`${issue.line ? ` (line ${issue.line})` : ""}\n\n`;
    }

    if (issue.suggestion) {
      body += `**Suggested Fix:**\n${issue.suggestion}\n\n`;
    }

    body += "---\n*This issue was automatically generated by docs-check*";

    const response = await this.octokit.rest.issues.create({
      owner: repository.owner,
      repo: repository.repo,
      title: issue.title,
      body,
      labels,
    });

    return {
      type: "issue",
      url: response.data.html_url,
      number: response.data.number,
    };
  }

  private async createGroupedIssue(
    repository: GitHubRepository,
    title: string,
    issues: DocumentationIssue[],
    severity: string
  ): Promise<GitHubActionResult> {
    let body = `This issue contains ${issues.length} ${severity} priority documentation issues found during automated analysis.\n\n`;

    for (let i = 0; i < issues.length; i++) {
      const issue = issues[i];
      body += `## ${i + 1}. ${issue.title}\n\n`;
      body += `**Type:** ${issue.type}\n\n`;
      body += `**Description:** ${issue.description}\n\n`;

      if (issue.file) {
        body += `**File:** \`${issue.file}\`${issue.line ? ` (line ${issue.line})` : ""}\n\n`;
      }

      if (issue.suggestion) {
        body += `**Suggested Fix:** ${issue.suggestion}\n\n`;
      }

      body += "---\n\n";
    }

    body += "*This issue was automatically generated by docs-check*";

    const labels = ["documentation", severity === "medium" ? "enhancement" : "good first issue"];

    const response = await this.octokit.rest.issues.create({
      owner: repository.owner,
      repo: repository.repo,
      title,
      body,
      labels,
    });

    return {
      type: "issue",
      url: response.data.html_url,
      number: response.data.number,
    };
  }

  async createPullRequestWithFixes(
    repository: GitHubRepository,
    analysisResult: AnalysisResult,
    repoPath: string
  ): Promise<GitHubActionResult | null> {
    try {
      const gitOps = new GitOperations(repoPath);
      const branchName = `docs-check-fixes-${Date.now()}`;

      // Create a new branch
      await gitOps.createBranch(repoPath, branchName);

      // Apply fixes for simple issues
      const fixedIssues = await this.applyAutomaticFixes(repoPath, analysisResult.issues);

      if (fixedIssues.length === 0) {
        console.log("No automatic fixes could be applied.");
        return null;
      }

      // Commit changes
      const commitMessage = `docs: Fix ${fixedIssues.length} documentation issues\n\nAutomatic fixes applied for:\n${fixedIssues.map((issue) => `- ${issue.title}`).join("\n")}`;

      await gitOps.commitChanges(repoPath, commitMessage);

      // Push branch (this would require authentication setup)
      // await gitOps.pushBranch(repoPath, branchName);

      // Create pull request
      const prTitle = `ðŸ“š Fix documentation issues (${fixedIssues.length} fixes)`;
      const prBody = this.generatePullRequestBody(fixedIssues, analysisResult);

      const response = await this.octokit.rest.pulls.create({
        owner: repository.owner,
        repo: repository.repo,
        title: prTitle,
        head: branchName,
        base: "main", // Assuming main branch, could be made configurable
        body: prBody,
      });

      return {
        type: "pull-request",
        url: response.data.html_url,
        number: response.data.number,
      };
    } catch (error) {
      throw new Error(
        `Failed to create pull request: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private async applyAutomaticFixes(
    repoPath: string,
    issues: DocumentationIssue[]
  ): Promise<DocumentationIssue[]> {
    const fixableIssues = issues.filter(
      (issue) =>
        issue.type === "broken-link" || (issue.type === "missing" && issue.suggestion && issue.file)
    );

    const fixedIssues: DocumentationIssue[] = [];

    for (const issue of fixableIssues) {
      try {
        if (issue.file && issue.suggestion) {
          const filePath = join(repoPath, issue.file);

          // Read file content
          const content = await fs.readFile(filePath, "utf-8");

          // Apply simple text replacements (this is a basic implementation)
          // In a real scenario, you'd want more sophisticated fixing logic
          let fixedContent = content;

          if (issue.type === "missing" && issue.suggestion.includes("add")) {
            // For missing content, append at the end of file
            fixedContent += `\n\n${issue.suggestion}\n`;
          }

          // Write back to file
          await fs.writeFile(filePath, fixedContent, "utf-8");
          fixedIssues.push(issue);
        }
      } catch (error) {
        console.warn(`Failed to apply fix for issue "${issue.title}": ${error}`);
      }
    }

    return fixedIssues;
  }

  private generatePullRequestBody(
    fixedIssues: DocumentationIssue[],
    analysisResult: AnalysisResult
  ): string {
    let body = `## ðŸ“š Documentation Fixes\n\n`;
    body += `This PR automatically fixes ${fixedIssues.length} documentation issues identified during analysis.\n\n`;

    body += `### Fixed Issues:\n\n`;
    for (const issue of fixedIssues) {
      body += `- **${issue.title}** (${issue.type})\n`;
      body += `  - File: \`${issue.file}\`\n`;
      if (issue.line) {
        body += `  - Line: ${issue.line}\n`;
      }
      body += `  - Description: ${issue.description}\n\n`;
    }

    const remainingIssues = analysisResult.issues.length - fixedIssues.length;
    if (remainingIssues > 0) {
      body += `### Remaining Issues:\n\n`;
      body += `${remainingIssues} issues require manual attention and will be created as separate GitHub issues.\n\n`;
    }

    body += `---\n*This PR was automatically generated by docs-check*`;

    return body;
  }

  private getLabelsForIssue(issue: DocumentationIssue): string[] {
    const labels = ["documentation"];

    switch (issue.severity) {
      case "high":
        labels.push("priority: high", "bug");
        break;
      case "medium":
        labels.push("enhancement");
        break;
      case "low":
        labels.push("good first issue");
        break;
    }

    switch (issue.type) {
      case "broken-link":
        labels.push("bug");
        break;
      case "missing":
        labels.push("enhancement");
        break;
      case "unclear":
        labels.push("enhancement");
        break;
      case "outdated":
        labels.push("maintenance");
        break;
    }

    return labels;
  }
}
